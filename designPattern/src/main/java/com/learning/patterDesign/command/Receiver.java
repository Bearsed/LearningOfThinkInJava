package com.learning.patterDesign.command;

/*

目的：

任何模式的出现，都是为了解决一些特定的场景的耦合问题，以达到对修改封闭，对扩展开放的效果。命令模式也不例外：

命令模式是为了解决命令的请求者和命令的实现者之间的耦合关系。

解决了这种耦合的好处我认为主要有两点：

1.更方便的对命令进行扩展（注意：这不是主要的优势，后面会提到）

2.对多个命令的统一控制（这种控制包括但不限于：队列、撤销/恢复、记录日志等等）

模式解析：

经典的命令模式包括4个角色：

Command：定义命令的统一接口

ConcreteCommand：Command接口的实现者，用来执行具体的命令，某些情况下可以直接用来充当Receiver。

Receiver：命令的实际执行者

Invoker：命令的请求者，是命令模式中最重要的角色。这个角色用来对各个命令进行控制。

下面对上面四个角色的经典实现用代码来进行说明，这也是大部分文章对命令模式的运用方式。
 */
public abstract class Receiver {
    //抽象接收者，定义每个接收者都必须完成的逻辑
    public abstract void doSomething();
}
